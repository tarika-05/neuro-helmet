<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Offline Verifier — Standalone (No Server)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; padding: 0; background: #0b0f12; color: #e6edf3; }
    .container { max-width: 900px; margin: 40px auto; padding: 0 16px; }
    .card { background: #12181d; border: 1px solid #1f2937; padding: 16px; border-radius: 12px; margin: 16px 0; box-shadow: 0 4px 18px rgba(0,0,0,.25); }
    textarea, input[type=text] { width: 100%; background: #0f1419; border: 1px solid #2a3544; color: #e6edf3; border-radius: 8px; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    button { background: #2563eb; color: white; border: none; border-radius: 10px; padding: 10px 16px; font-weight: 600; cursor: pointer; }
    button:hover { background: #1d4ed8; }
    .muted { color: #94a3b8; }
    pre { background: #0f1419; padding: 12px; border-radius: 8px; overflow-x: auto; border: 1px solid #2a3544; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Offline Document Verifier (Standalone)</h1>
    <p class="muted">Runs entirely in your browser. Paste a token or select a QR image. Uses WebCrypto (Ed25519). No network required.</p>

    <div class="card">
      <label>Token (text):</label>
      <textarea id="token" rows="6" placeholder="BASE64URL(header).BASE64URL(payload).BASE64URL(signature)"></textarea>
      <div style="margin:10px 0;">— OR —</div>
      <label>QR Image (PNG/JPG):</label>
      <input type="file" id="qr" accept="image/*"/>
      <div style="margin:12px 0;">
        <button id="verifyBtn">Verify Offline</button>
      </div>
      <div id="result" style="font-weight:700;"></div>
      <h3>Header</h3>
      <pre id="headerPre"></pre>
      <h3>Payload</h3>
      <pre id="payloadPre"></pre>
    </div>

    <div class="card">
      <h3>About</h3>
      <p class="muted">Public key (Ed25519, RAW base64url) embedded for verification:</p>
      <pre id="pubkeyPre"></pre>
      <p class="muted">If your browser does not support Ed25519 in WebCrypto, use the Flask verifier in <code>verifier_app/</code>.</p>
    </div>
  </div>

  <script>
    // Embedded public key (RAW base64url)
    const PUB_RAW_B64U = "__PUB_RAW_B64U__";
    document.getElementById('pubkeyPre').textContent = PUB_RAW_B64U;

    function b64uToBytes(s){
      s = s.replace(/-/g,'+').replace(/_/g,'/'); const pad = '='.repeat((4 - s.length % 4) % 4);
      const str = atob(s + pad); const arr = new Uint8Array(str.length);
      for (let i=0;i<str.length;i++) arr[i] = str.charCodeAt(i); return arr;
    }
    function bytesToB64u(bytes){
      let bin = ''; bytes.forEach(b => bin += String.fromCharCode(b));
      return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }

    async function importEd25519Raw(rawB64u){
      const raw = b64uToBytes(rawB64u);
      // Wrap RAW into SPKI so WebCrypto can import in most browsers
      // Simple SPKI header for Ed25519: 302a300506032b6570032100 || raw(32)
      const spki = new Uint8Array(12 + 32);
      spki.set([0x30,0x2a,0x30,0x05,0x06,0x03,0x2b,0x65,0x70,0x03,0x21,0x00], 0);
      spki.set(raw, 12);
      return await crypto.subtle.importKey(
        'spki', spki.buffer, { name: 'Ed25519' }, false, ['verify']
      );
    }

    function parseToken(tk){
      const parts = tk.split('.'); if(parts.length !== 3) throw new Error('Invalid token format');
      const [h_b, p_b, s_b] = parts;
      const dec = (x)=> new TextDecoder().decode(b64uToBytes(x));
      const header = JSON.parse(dec(h_b));
      const payload = JSON.parse(dec(p_b));
      const sig = b64uToBytes(s_b);
      const data = new TextEncoder().encode(`${h_b}.${p_b}`);
      return {header, payload, sig, data};
    }

    async function verifyToken(tk, pubKey){
      const {header, payload, sig, data} = parseToken(tk);
      const ok = await crypto.subtle.verify({name:'Ed25519'}, pubKey, sig, data);
      // temporal checks
      const now = Math.floor(Date.now()/1000);
      if (ok){
        if (header.nbf && now < header.nbf) return {ok:false, reason:'Token not yet valid', header, payload};
        if (header.exp && now > header.exp) return {ok:false, reason:'Token expired', header, payload};
        // simple domain checks
        const reasons = [];
        const today = new Date().toISOString().slice(0,10);
        function dateLt(a,b){ return a < b; }
        if (payload.insurance_valid && dateLt(payload.insurance_valid, today)) reasons.push(`insurance_valid expired on ${payload.insurance_valid}`);
        if (payload.puc_valid && dateLt(payload.puc_valid, today)) reasons.push(`puc_valid expired on ${payload.puc_valid}`);
        if (payload.rc_status && String(payload.rc_status).toUpperCase() !== 'ACTIVE') reasons.push(`RC status is ${payload.rc_status}`);
        if (reasons.length) return {ok:false, reason:reasons.join('; '), header, payload};
        return {ok:true, header, payload};
      }
      return {ok:false, reason:'Signature verification failed', header, payload};
    }

    async function readQR(file){
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = async () => {
            // Use the new BarcodeDetector if available
            if ('BarcodeDetector' in window) {
              try {
                const detector = new BarcodeDetector({formats: ['qr_code']});
                const bitmap = await createImageBitmap(img);
                const results = await detector.detect(bitmap);
                if (results && results[0]) return resolve(results[0].rawValue);
              } catch(e){}
            }
            // Fallback: ask user to paste token
            resolve('');
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    }

    (async function(){
      const pubKey = await importEd25519Raw(PUB_RAW_B64U);
      const tokenEl = document.getElementById('token');
      const qrEl = document.getElementById('qr');
      const out = document.getElementById('result');
      const hpre = document.getElementById('headerPre');
      const ppre = document.getElementById('payloadPre');

      document.getElementById('verifyBtn').addEventListener('click', async () => {
        let tk = tokenEl.value.trim();
        if (!tk && qrEl.files && qrEl.files[0]) {
          tk = await readQR(qrEl.files[0]);
          if (tk) tokenEl.value = tk;
        }
        if (!tk){ out.textContent = 'Please paste a token or select a QR image.'; return; }

        try{
          const res = await verifyToken(tk, pubKey);
          hpre.textContent = JSON.stringify(res.header||{}, null, 2);
          ppre.textContent = JSON.stringify(res.payload||{}, null, 2);
          out.textContent = res.ok ? '✅ VALID: All checks passed' : `❌ INVALID: ${res.reason}`;
        }catch(e){
          out.textContent = '❌ Error: ' + e.message;
        }
      });
    })();
  </script>
</body>
</html>